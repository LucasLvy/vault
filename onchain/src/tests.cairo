use core::option::OptionTrait;
use core::starknet::SyscallResultTrait;
use core::traits::TryInto;
use openzeppelin::presets::ERC20Upgradeable::TEST_CLASS_HASH;
use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
use openzeppelin::utils::serde::SerializedAppend;
use starknet::secp256_trait::{recover_public_key, Secp256PointTrait, Signature, is_valid_signature};
use starknet::secp256r1::{Secp256r1Point, Secp256r1PointImpl};
use starknet::testing::set_contract_address;
use starknet::{ContractAddress, deploy_syscall, contract_address_const};
use starknet::{secp256r1::Secp256r1Impl};
use vault::contracts::account::Account::{
    ClaimLinkTraitDispatcher, ClaimLinkTraitDispatcherTrait, Claim
};
use vault::contracts::account::Account;

/// Deploys a mock erc20 contract.
fn deploy_erc20(recipient: ContractAddress, initial_supply: u256) -> IERC20Dispatcher {
    let name: ByteArray = "Fake token";
    let symbol: ByteArray = "FT";
    let mut calldata = array![];

    calldata.append_serde(name);
    calldata.append_serde(symbol);
    calldata.append_serde(2 * initial_supply);
    calldata.append_serde(recipient);
    calldata.append_serde(recipient);

    let (address, _) = deploy_syscall(
        TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
    )
        .unwrap_syscall();
    IERC20Dispatcher { contract_address: address }
}

const PUBLIC_KEY: (u256, u256) =
    (
        0x817e6fe65ffaf529a672dc3f6b4c709db8e88f163a7831739df91cf0daf81133,
        0x4bdae6ef158afd49d946c36d8bf3c8efc359a50e1f2bc043368230ed9e6d610d
    );
const LIMIT: u256 = 0x1000000000000;
const AMOUNT: u256 = 0x123456789;
// Fake value generated by the test runner
const USDC_ADDRESS: felt252 = 0x7880f487915d45e939b41d22488bd30ad3f07ad5da8cb4655f83244c783cdef;
const R: u256 = 0x9b85799011b047cfdfe97e9856e016f0b58ba985fcf1f86c4b1f70b32f91e059;
const S: u256 = 0x457b6e074df76bb6db18b901f5297af83b31fe6358cf3ae76d6c273f1cfca406;

fn valid_signature() -> Array<felt252> {
    let mut sig = array![];
    sig.append_serde(R);
    sig.append_serde(S);
    sig
}

fn invalid_signature() -> Array<felt252> {
    let mut sig = array![];
    sig.append_serde(S);
    sig.append_serde(R);
    sig
}

fn approver() -> ContractAddress {
    contract_address_const::<0x0>()
}
fn constructor_calldata() -> Array<felt252> {
    let mut res = array![];
    res.append_serde(PUBLIC_KEY);
    res.append_serde(approver());
    res.append_serde(LIMIT);
    res
}

#[test]
fn test_claim_link_valid_signature_not_already_claimed_works() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);
    set_contract_address(contract_address_const::<0x1>());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}

#[test]
#[should_panic(expected: ("Invalid signature for claim", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_invalid_signature_not_already_claimed_fails() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);
    set_contract_address(contract_address_const::<0x1>());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: invalid_signature());
}

#[test]
#[should_panic(expected: ("Link already used", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_valid_signature_already_claimed_fails() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);
    set_contract_address(contract_address_const::<0x1>());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}
