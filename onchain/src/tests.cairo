use core::option::OptionTrait;
use core::starknet::SyscallResultTrait;
use core::traits::TryInto;
use openzeppelin::presets::ERC20Upgradeable::TEST_CLASS_HASH;
use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
use openzeppelin::utils::serde::SerializedAppend;
use starknet::secp256_trait::{recover_public_key, Secp256PointTrait, Signature, is_valid_signature};
use starknet::secp256r1::{Secp256r1Point, Secp256r1PointImpl};
use starknet::testing::set_contract_address;
use starknet::{ContractAddress, deploy_syscall, contract_address_const};
use starknet::{secp256r1::Secp256r1Impl};
use vault::contracts::account::Account::{
    ClaimLinkTraitDispatcher, ClaimLinkTraitDispatcherTrait, Claim
};
use vault::contracts::account::Account;

/// Deploys a mock erc20 contract.
fn deploy_erc20(recipient: ContractAddress, initial_supply: u256) -> IERC20Dispatcher {
    let name: ByteArray = "Fake token";
    let symbol: ByteArray = "FT";
    let mut calldata = array![];

    calldata.append_serde(name);
    calldata.append_serde(symbol);
    calldata.append_serde(2 * initial_supply);
    calldata.append_serde(recipient);
    calldata.append_serde(recipient);

    let (address, _) = deploy_syscall(
        TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
    )
        .unwrap_syscall();
    IERC20Dispatcher { contract_address: address }
}

const PUBLIC_KEY: (u256, u256) =
    (
        0xa0cb79205a8355d9c8be3a361de8068cbb7d96c17a2fc7ae4ff17facdb827b4d,
        0x534fafc9e92ef2408553744e545b041fdf3e36b88c3ad825c86bd6d37d1211ca
    );
const LIMIT: u256 = 0x1000000000000;
const PRIVATE_KEY: felt252 = 0x0328fe6d093f236a354c3ee33563d2c6a1ba6b7a4b4e0859d99d3df1fe0b1a7c;
const AMOUNT: u256 = 0x123456789;
// Fake value generated by the test runner
const USDC_ADDRESS: felt252 = 0x7880f487915d45e939b41d22488bd30ad3f07ad5da8cb4655f83244c783cdef;
const R: u256 = 0x00ddb6157091f11871ccb00a8b13cc18367a783a32498be03512aa4106d2443a63;
const S: u256 = 0xa4d89f1130b7c3ab9188cd1a71f96dd5fb9b7eecd5e57d2762bca7d844e5ab13;

fn valid_signature() -> Array<felt252> {
    let mut sig = array![];
    sig.append_serde(R);
    sig.append_serde(S);
    sig
}

fn invalid_signature() -> Array<felt252> {
    let mut sig = array![];
    sig.append_serde(S);
    sig.append_serde(R);
    sig
}

fn approver() -> ContractAddress {
    contract_address_const::<0x0>()
}
fn constructor_calldata() -> Array<felt252> {
    let mut res = array![];
    res.append_serde(PUBLIC_KEY);
    res.append_serde(approver());
    res.append_serde(LIMIT);
    res
}

#[test]
fn test_claim_link_valid_signature_not_already_claimed_works() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);
    set_contract_address(contract_address_const::<0x1>());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}

#[test]
#[should_panic(expected: ("Invalid signature for claim", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_invalid_signature_not_already_claimed_fails() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);
    set_contract_address(contract_address_const::<0x1>());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: invalid_signature());
}

#[test]
#[should_panic(expected: ("Link already used", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_valid_signature_already_claimed_fails() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);
    set_contract_address(contract_address_const::<0x1>());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}
