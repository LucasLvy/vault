use core::option::OptionTrait;
use core::starknet::SyscallResultTrait;
use core::traits::TryInto;
use openzeppelin::presets::ERC20Upgradeable::TEST_CLASS_HASH;
use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
use openzeppelin::utils::serde::SerializedAppend;
use starknet::testing::set_contract_address;
use starknet::{ContractAddress, deploy_syscall, contract_address_const};
use vault::contracts::account::Account::{
    ClaimLinkTraitDispatcher, ClaimLinkTraitDispatcherTrait, Claim
};
use vault::contracts::account::Account;

/// Deploys a mock erc20 contract.
fn deploy_erc20(recipient: ContractAddress, initial_supply: u256) -> IERC20Dispatcher {
    let name: ByteArray = "Fake token";
    let symbol: ByteArray = "FT";
    let mut calldata = array![];

    calldata.append_serde(name);
    calldata.append_serde(symbol);
    calldata.append_serde(2 * initial_supply);
    calldata.append_serde(recipient);
    calldata.append_serde(recipient);

    let (address, _) = deploy_syscall(
        TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
    )
        .unwrap_syscall();
    IERC20Dispatcher { contract_address: address }
}

const PUBLIC_KEY: felt252 = 0x07ab7a2723e7095217dfa798c277583996895e9eaff943f5d781a0ae2af194c7;
const LIMIT: u256 = 0x1000000000000;
const PRIVATE_KEY: felt252 = 0x0328fe6d093f236a354c3ee33563d2c6a1ba6b7a4b4e0859d99d3df1fe0b1a7c;
const AMOUNT: u256 = 0x123456789;
// Fake value generated by the test runner
const USDC_ADDRESS: felt252 = 0x7880f487915d45e939b41d22488bd30ad3f07ad5da8cb4655f83244c783cdef;
const R: felt252 = 0x7f3c86188482bcc85d6d8f0a9d325add2b3fb3368ae4c143a485b37b14d11fd;
const S: felt252 = 0x48d761c9c4dd5dd9c1c617cda41610a9a837272c959eadd15dc038eea431d17;

fn valid_signature() -> Array<felt252> {
    array![R, S]
}
fn invalid_signature() -> Array<felt252> {
    array![S, R]
}

fn approver() -> ContractAddress {
    contract_address_const::<0x0>()
}
fn constructor_calldata() -> Array<felt252> {
    let mut res = array![];
    res.append_serde(PUBLIC_KEY);
    res.append_serde(approver());
    res.append_serde(LIMIT);
    res
}

#[test]
fn test_claim_link_valid_signature_not_already_claimed_works() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);
    set_contract_address(contract_address_const::<0x1>());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}

#[test]
#[should_panic(expected: ("Invalid signature for claim", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_invalid_signature_not_already_claimed_fails() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);
    set_contract_address(contract_address_const::<0x1>());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: invalid_signature());
}

#[test]
#[should_panic(expected: ("Link already used", 'ENTRYPOINT_FAILED'))]
fn test_claim_link_valid_signature_already_claimed_fails() {
    let (address, _) = deploy_syscall(
        Account::TEST_CLASS_HASH.try_into().unwrap(), 0, constructor_calldata().span(), true
    )
        .unwrap_syscall();
    let erc20 = deploy_erc20(address, AMOUNT);

    let claim_dispatcher = ClaimLinkTraitDispatcher { contract_address: address };
    claim_dispatcher.set_usdc_address(erc20.contract_address);
    set_contract_address(contract_address_const::<0x1>());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
    claim_dispatcher.claim(Claim { amount: AMOUNT, nonce: 0 }, signature: valid_signature());
}
